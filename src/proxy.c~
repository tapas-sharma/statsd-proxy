#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/socket.h> 
#include <netinet/in.h> 
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <errno.h>
#include <hiredis.h>

#include "log.h"
#include "conf_struct.h"
#include "queue.h"

#define TAKE_WRITE_LOCK(x) pthread_rwlock_wrlock(x)
#define TAKE_READ_LOCK(x) pthread_rwlock_rdlock(x)
#define UNLOCK(x) pthread_rwlock_unlock(x)

//global configuration for proxy and connections
confStruct configuration;
connStruct connections;
Queue *req_queue; // all the requests are here

pthread_rwlock_t req_queue_lock; // lock on the queue
pthread_rwlockattr_t rwattr ; //attributes for this lock

/**
 * This will run in a while(1), processing the client UDP requests
 */
void *process_client(void *threadname)
{
  char msg[ MAX_BUF_TO_RECV + 2 ];// 1 for code & 1 for null terminator
  char *all = NULL;
  const char *name = threadname;
  struct sockaddr_in cliAddr;
  socklen_t cliLen = sizeof(cliAddr);
  socklen_t default_len = cliLen;
  int rcv;
  int n = -1;
  open_statsd_connection();
  while (1)
    {
      n = -1;
      cliLen = default_len;
      bzero(&msg, MAX_BUF_TO_RECV+2);
      //peek how much data is on the UDP socket
      n = recvfrom(connections.proxy_fd, msg, MAX_BUF_TO_RECV+1, MSG_PEEK,
		   (struct sockaddr *) &cliAddr, &cliLen);
      
      if(n < 0)
	{
	  log(LOG_ERROR, "[%s] Could not receive data for udp_sock : %s", name,strerror(errno) );
	  continue;
	}
      //malloc the buffer which we will use for reading in.
      all = (char *)malloc(n);
      //read that data
      rcv = recv(connections.proxy_fd, all, n+1, 0);
      if(rcv < 0)
	{
	  log(LOG_ERROR, "[%s] Could not receive %d bytes data from udp_sock : %s",
	      name, n, strerror(errno) );
	  continue;
	}
      //enqueue the data in the request queue
      TAKE_WRITE_LOCK(&req_queue_lock);
      log(LOG_DEBUG, "Data Rcvd is: %s", all);
      enqueue(&req_queue, all, n, (struct sockaddr *)&cliAddr, cliLen);
      UNLOCK(&req_queue_lock);
      send_data_to_statsd(all, n, (struct sockaddr *)&cliAddr, cliLen);
      free(all);
    }
  
  log(LOG_ERROR,"[%s] Exiting client thread.", name);
  pthread_exit(NULL);
  
  return (void*)TRUE;
}

ret_val create_server_side_connections()
{
  return TRUE;  
}

int main(int argc, char *argv[])
{
  int ret;
  pthread_t threads[2];
      
  init_configuration();
  init_log_file();
  if(argc==2)
    {
      log(LOG_INFO,"Loading configuration from %s.", argv[1]);
      read_config_file(argv[1]);
    }
  print_configuration();
  fflush(configuration.log_file);
  /**
   * initialize the connection object, since there are no default
   * values, we can just bzero it here
   */
  bzero(&connections, sizeof(connections));
  
  connections.proxy_fd = get_socket(configuration.proxy_port, configuration.proxy_ip, TRUE);
  if(connections.proxy_fd == FALSE || connections.proxy_fd < 0)
    {
      log(LOG_ERROR, "Cannot open the socket for proxy, please change the configuration and try again.");
      exit(1);
    }
  //init the queue to NULL
  req_queue = NULL;
  //Init the lock for the queue
  pthread_rwlockattr_init(&rwattr);
  pthread_rwlockattr_setkind_np( &rwattr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP ) ;
  pthread_rwlock_init( &req_queue_lock, &rwattr ) ;

  ret = pthread_create(&threads[0], NULL, process_client, (void *)"Client_Processing_Thread");
  if(ret)
    {
      log(LOG_ERROR, "The return code from the pthread_create was %d,"
	  "for Client_Processing_Thread i.e %s", ret, strerror(errno));
      exit(1);
    }

  ret = create_server_side_connections();
  if(ret == FALSE)
    {
      log(LOG_ERROR, "Cannot open server side connections, please check configuration.\n"
	  "Exiting....");
      exit(1);
    }

  
  /* ret = pthread_create(&threads[1], NULL, process_client, (void *)"Client_Processing_Thread"); */
  /* if(ret) */
  /*   { */
  /*     log(LOG_ERROR, "The return code from the pthread_create was %d," */
  /* 	  "for Server_Processing_Thread i.e %s", ret, strerror(errno)); */
  /*     exit(1); */
  /*   } */
  pthread_join(threads[0],NULL);
  pthread_exit(NULL);
  return 0;
}
